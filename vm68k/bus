/* -*-C++-*- */
/* Libvm68k - M68000 virtual machine library
   Copyright (C) 1998-2002 Hypercore Software Design, Ltd.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
   USA.  */

#ifndef _VM68K_BUS
#define _VM68K_BUS 1

#include <vm68k/type>
#include <vector>
#include <string>
#include <exception>

namespace vm68k
{
  /* Function code, which identifies an access type.  */
  enum function_code
    {USER_DATA = 1,
     USER_PROGRAM = 2,
     SUPER_DATA = 5,
     SUPER_PROGRAM = 6};

  enum bus_direction
    {WRITE = 0,
     READ = 0x10};
}

namespace vm68k
{
  /* Bus error exception.  */
  class bus_error: public std::exception
  {
  private:
    const uint32_type _address;
    const uint16_type _ssw;

  public:
    bus_error(uint32_type address, uint16_type ssw) throw ();

  public:
    uint32_type address() const throw () {return _address;}
    uint16_type ssw() const throw () {return _ssw;}
    const char *what() const throw ();
  };

  inline
  bus_error::bus_error(uint32_type address,
		       uint16_type ssw) throw ()
    : _address(address),
      _ssw(ssw)
  {
  }

  /* Address error exception.  */
  class address_error: public std::exception
  {
  private:
    const uint32_type _address;
    const uint16_type _ssw;

  public:
    address_error(uint32_type address, uint16_type ssw) throw ();

  public:
    uint32_type address() const throw () {return _address;}
    uint16_type ssw() const throw () {return _ssw;}
    const char *what() const throw ();
  };

  inline
  address_error::address_error(uint32_type address,
			       uint16_type ssw) throw ()
    : _address(address),
      _ssw(ssw)
  {
  }
}

namespace vm68k
{
  /* Abstract device that can be mapped in a memory address space.  */
  class memory_device
  {
  public:
    virtual int load_8(uint32_type address,
		       function_code fc) const throw (bus_error) = 0;
    virtual uint16_type load_16(uint32_type address,
				function_code fc) const throw (bus_error) = 0;
    virtual uint32_type load_32(uint32_type address,
				function_code fc) const throw (bus_error);

  public:
    virtual void store_8(uint32_type address, int value,
			 function_code fc) throw (bus_error) = 0;
    virtual void store_16(uint32_type address, uint16_type value,
			  function_code fc) throw (bus_error) = 0;
    virtual void store_32(uint32_type address, uint32_type value,
			  function_code fc) throw (bus_error);

  public:
    virtual ~memory_device() {}
  };

  /* Memory in the programmer's view.  A memory has a single address
     space and consists of memory pages.  */
  class memory
  {
  private:
    typedef std::vector<memory_device *> page_table_type;
    page_table_type page_table;

  public:
    memory();

  public:
    /* Returns one byte at address ADDRESS in this address space.  */
    int load_8(uint32_type address,
	       function_code fc) const throw (bus_error);

    /* Returns one word at address ADDRESS in this address space.  Any
       unaligned address will be handled.  */
    uint16_type load_16(uint32_type address,
			function_code fc) const throw (bus_error,
						       address_error);

    /* Returns one word at address ADDRESS in this address space.
       The address must be word-aligned.  */
    uint16_type load_16_aligned(uint32_type address,
				function_code fc) const throw (bus_error);

    /* Returns one long word at address ADDRESS in this address space.
       Any unaligned address will be handled.  */
    uint32_type load_32(uint32_type address,
			function_code fc) const throw (bus_error,
						       address_error);

    std::string load_string(uint32_type address,
			    function_code fc) const throw (bus_error);

  public:
    /* Stores byte VALUE at address ADDRESS in this address space.  */
    void store_8(uint32_type address, int value,
		 function_code fc) throw (bus_error);

    /* Stores word VALUE at address ADDRESS in this address space.
       Any unaligned address will be handled.  */
    void store_16(uint32_type address, uint16_type value,
		  function_code fc) throw (bus_error, address_error);

    /* Stores word VALUE at address ADDRESS in this address space.
       The address must be word-aligned.  */
    void store_16_aligned(uint32_type address, uint16_type value,
			  function_code fc) throw (bus_error);

    /* Stores long word VALUE at address ADDRESS in this address
       space.  Any unaligned address will be handled.  */
    void store_32(uint32_type address, uint32_type value,
		  function_code fc) throw (bus_error, address_error);

    void store_string(uint32_type address, const std::string &,
		      function_code fc) throw (bus_error);

  public:
    void copy_out(uint32_type, void *, size_t,
		  function_code fc) const throw (bus_error);
    void copy_in(uint32_type, const void *, size_t,
		 function_code fc) throw (bus_error);

  public:
    // External mc68000 address is 24-bit size.
    static uint32_type address_mask() throw () {return 0xffffff;}
    static uint32_type page_size() throw () {return 0x1000;}
    static memory_device *no_device() throw ();

  public:
    /* Fills an address range with memory.  */
    void add(uint32_type, uint32_type, memory_device *);

  protected:
    /* Finds a page that contains address ADDRESS.  */
    page_table_type::iterator find_device(uint32_type address);
    page_table_type::const_iterator find_device(uint32_type address) const;

  public:
    virtual ~memory();
  };

  inline memory::page_table_type::iterator
  memory::find_device(uint32_type address)
  {
    address &= address_mask();
    return page_table.begin() + address / page_size();
  }

  inline memory::page_table_type::const_iterator
  memory::find_device(uint32_type address) const
  {
    return const_cast<memory *>(this)->find_device(address);
  }

  inline int
  memory::load_8(uint32_type address,
		 function_code fc) const throw (bus_error)
  {
    const memory_device *p = *this->find_device(address);
    return p->load_8(address, fc);
  }

  inline uint16_type
  memory::load_16_aligned(uint32_type address,
			  function_code fc) const throw (bus_error)
  {
    const memory_device *p = *this->find_device(address);
    return p->load_16(address, fc);
  }

  inline void
  memory::store_8(uint32_type address, int value,
		  function_code fc) throw (bus_error)
  {
    memory_device *p = *this->find_device(address);
    p->store_8(address, value, fc);
  }

  inline void
  memory::store_16_aligned(uint32_type address, uint16_type value,
		      function_code fc) throw (bus_error)
  {
    memory_device *p = *this->find_device(address);
    p->store_16(address, value, fc);
  }
}

#endif /* not _VM68K_BUS */
