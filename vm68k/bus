/* -*-C++-*- */
/* Libvm68k - M68000 virtual machine library
   Copyright (C) 1998-2002 Hypercore Software Design, Ltd.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
   USA.  */

#ifndef _VM68K_BUS
#define _VM68K_BUS 1

#include <vm68k/type>
#include <vector>
#include <string>
#include <exception>

namespace vm68k
{
  const int PAGE_SHIFT = 12;
  const uint32_type PAGE_SIZE = uint32_type(1) << PAGE_SHIFT;

  // External mc68000 address is 24-bit size.
  const int ADDRESS_BIT = 24;
  const uint32_type NPAGES = uint32_type(1) << ADDRESS_BIT - PAGE_SHIFT;

  /* Function code, which identifies an access type.  */
  enum function_code
    {USER_DATA = 1,
     USER_PROGRAM = 2,
     SUPER_DATA = 5,
     SUPER_PROGRAM = 6};

  enum bus_direction
    {WRITE = 0,
     READ = 0x10};
}

namespace vm68k
{
  /* Bus error exception.  */
  class bus_error: public std::exception
  {
  private:
    const uint32_type _address;
    const uint16_type _ssw;

  public:
    bus_error(uint32_type address, uint16_type ssw) throw ();

  public:
    uint32_type address() const throw () {return _address;}
    uint16_type ssw() const throw () {return _ssw;}
    const char *what() const throw ();
  };

  inline
  bus_error::bus_error(uint32_type address,
		       uint16_type ssw) throw ()
    : _address(address),
      _ssw(ssw)
  {
  }

  /* Address error exception.  */
  class address_error: public std::exception
  {
  private:
    const uint32_type _address;
    const uint16_type _ssw;

  public:
    address_error(uint32_type address, uint16_type ssw) throw ();

  public:
    uint32_type address() const throw () {return _address;}
    uint16_type ssw() const throw () {return _ssw;}
    const char *what() const throw ();
  };

  inline
  address_error::address_error(uint32_type address,
			       uint16_type ssw) throw ()
    : _address(address),
      _ssw(ssw)
  {
  }
}

namespace vm68k
{
  /* Abstract bus target.  A bus target will be mapped within an address
     space.  */
  class bus_target
  {
  public:
    virtual ~bus_target() {}

  public:
    virtual int get_8(uint32_type address, function_code fc) const
      throw (bus_error) = 0;
    virtual uint16_type get_16(uint32_type address, function_code fc) const
      throw (bus_error) = 0;
    virtual uint32_type get_32(uint32_type address, function_code fc) const
      throw (bus_error);
    virtual void put_8(uint32_type address, int value, function_code fc)
      throw (bus_error) = 0;
    virtual void put_16(uint32_type address, uint16_type value,
			function_code fc) throw (bus_error) = 0;
    virtual void put_32(uint32_type address, uint32_type value,
			function_code fc) throw (bus_error);
  };

  /* Maps an address space to memories.  An address space is a
     software view of a target machine.  */
  class bus
  {
  protected:
    typedef std::vector<bus_target *> page_table_type;

  private:
    page_table_type page_table;

  public:
    bus();
    virtual ~bus();

  public:
    static bus_target *no_target() throw ();

  protected:
    /* Finds a page that contains address ADDRESS.  */
    page_table_type::iterator
    find_memory(uint32_type address);
    page_table_type::const_iterator
    find_memory(uint32_type address) const;

  public:
    /* Fills an address range with memory.  */
    void fill_memory(uint32_type, uint32_type, bus_target *);

  public:
    /* Returns one byte at address ADDRESS in this address space.  */
    int get_8(uint32_type address, function_code fc) const
      throw (bus_error);

    /* Returns one word at address ADDRESS in this address space.  Any
       unaligned address will be handled.  */
    uint16_type get_16(uint32_type address, function_code fc) const
      throw (bus_error, address_error);

    /* Returns one word at address ADDRESS in this address space.
       The address must be word-aligned.  */
    uint16_type get_16_aligned(uint32_type address, function_code fc) const
      throw (bus_error);

    /* Returns one long word at address ADDRESS in this address space.
       Any unaligned address will be handled.  */
    uint32_type get_32(uint32_type address, function_code fc) const
      throw (bus_error, address_error);

    std::string get_string(uint32_type address, function_code fc) const;

    void read(uint32_type, void *, size_t, function_code fc) const;

    /* Stores byte VALUE at address ADDRESS in this address space.  */
    void put_8(uint32_type address, int value, function_code fc)
      throw (bus_error);

    /* Stores word VALUE at address ADDRESS in this address space.
       Any unaligned address will be handled.  */
    void put_16(uint32_type address, uint16_type value, function_code fc)
      throw (bus_error, address_error);

    /* Stores word VALUE at address ADDRESS in this address space.
       The address must be word-aligned.  */
    void put_16_aligned(uint32_type address, uint16_type value,
			  function_code fc)
      throw (bus_error);

    /* Stores long word VALUE at address ADDRESS in this address
       space.  Any unaligned address will be handled.  */
    void put_32(uint32_type address, uint32_type value, function_code fc)
      throw (bus_error, address_error);

    void put_string(uint32_type address, const std::string &, function_code fc);

    void write(uint32_type, const void *, size_t, function_code fc);
  };

  inline bus::page_table_type::iterator
  bus::find_memory(uint32_type address)
  {
    return page_table.begin() + (address >> PAGE_SHIFT) % NPAGES;
  }

  inline bus::page_table_type::const_iterator
  bus::find_memory(uint32_type address) const
  {
    return const_cast<bus *>(this)->find_memory(address);
  }

  inline int
  bus::get_8(uint32_type address, function_code fc) const throw (bus_error)
  {
    const bus_target *p = *this->find_memory(address);
    return p->get_8(address, fc);
  }

  inline uint16_type
  bus::get_16_aligned(uint32_type address, function_code fc) const
    throw (bus_error)
  {
    const bus_target *p = *this->find_memory(address);
    return p->get_16(address, fc);
  }

  inline void
  bus::put_8(uint32_type address, int value, function_code fc)
    throw (bus_error)
  {
    bus_target *p = *this->find_memory(address);
    p->put_8(address, value, fc);
  }

  inline void
  bus::put_16_aligned(uint32_type address, uint16_type value,
		      function_code fc) throw (bus_error)
  {
    bus_target *p = *this->find_memory(address);
    p->put_16(address, value, fc);
  }
}

#endif /* not _VM68K_BUS */
