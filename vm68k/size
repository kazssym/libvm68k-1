/* -*-C++-*- */
/* Libvm68k - M68000 virtual machine library
   Copyright (C) 1998-2002 Hypercore Software Design, Ltd.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
   USA.  */

#ifndef __VM68K_SIZE
#define __VM68K_SIZE 1

#include <vm68k/bus>

namespace vm68k
{
  template <class Size>
  struct size_methods
  {
    typedef typename Size::uint_type uint_type;
    typedef typename Size::sint_type sint_type;

    static uint_type load_aligned_u(const memory &, uint32_type address,
				    function_code);
    static sint_type load_aligned_s(const memory &, uint32_type address,
				    function_code);
  };

  template <class Size>
  inline typename Size::uint_type
  normal_u(Size, typename Size::uint_type value)
  {
    value &= Size::max();
    return value;
  }

  template <class Size>
  inline typename Size::sint_type
  normal_s(Size, typename Size::uint_type value)
  {
    value &= Size::max();
    if (value > Size::max() / 2)
      return -typename Size::sint_type(Size::max() - value) - 1;
    else
      return typename Size::sint_type(value);
  }

  template <class Size>
  inline uint32_type
  make_32(Size, uint32_type old, typename Size::uint_type value)
  {
    return old & ~uint32_type(Size::max()) | normal_u(Size(), value);
  }

  template <class Size>
  inline typename Size::uint_type
  size_methods<Size>::load_aligned_u(const memory &m, uint32_type address,
		       function_code fc)
  {
    return m.load_32(address, fc);
  }

  template <class Size>
  inline typename Size::sint_type
  size_methods<Size>::load_aligned_s(const memory &m, uint32_type address,
		       function_code fc)
  {
    return normal_sint(Size(), load_aligned_u(m, address, fc));
  }
}

namespace vm68k
{
  /* Access methods for byte data.  */
  struct byte
  {
    typedef int uint_type;
    typedef int sint_type;

    static uint32_type size() {return 1;}
    static uint32_type aligned_size() {return 2;}
    static int max() {return 0xff;}
    static const char *suffix() {return "b";}

    static int load(const memory &, uint32_type address,
		    function_code);
    static void store(memory &, uint32_type address, int value,
		      function_code);

    static int load_aligned_u(const memory &, uint32_type address,
			      function_code);
    static int load_aligned_s(const memory &, uint32_type address,
			      function_code);
  };

  inline int
  byte::load(const memory &m, uint32_type address,
	     function_code fc)
  {
    return m.load_8(address, fc);
  }

  inline void
  byte::store(memory &m, uint32_type address, int value,
	      function_code fc)
  {
    m.store_8(address, value, fc);
  }

  inline int
  byte::load_aligned_u(const memory &m, uint32_type address,
		       function_code fc)
  {
    return m.load_8(address | 1, fc);
  }

  inline int
  byte::load_aligned_s(const memory &m, uint32_type address,
		       function_code fc)
  {
    return normal_s(byte(), load_aligned_u(m, address, fc));
  }
}

namespace vm68k
{
  /* Access methods for word data.  */
  struct word
  {
    typedef uint16_type uint_type;
    typedef sint16_type sint_type;

    static uint32_type size() {return 2;}
    static uint32_type aligned_size() {return size();}
    static uint16_type max() {return 0xffff;}

    static uint16_type load(const memory &, uint32_type address,
			    function_code);
    static void store(memory &, uint32_type address, uint16_type value,
		      function_code);

    static uint16_type load_aligned_u(const memory &, uint32_type address,
				      function_code);
    static sint16_type load_aligned_s(const memory &, uint32_type address,
				      function_code);

    static const char *suffix() {return "w";}
  };

  inline uint16_type
  word::load(const memory &m, uint32_type address,
	     function_code fc)
  {
    return m.load_16(address, fc);
  }

  inline void
  word::store(memory &m, uint32_type address, uint16_type value, function_code fc)
  {
    m.store_16(address, value, fc);
  }

  inline uint16_type
  word::load_aligned_u(const memory &m, uint32_type address, function_code fc)
  {
    return m.load_16_aligned(address, fc);
  }

  inline sint16_type
  word::load_aligned_s(const memory &m, uint32_type address, function_code fc)
  {
    return normal_s(word(), load_aligned_u(m, address, fc));
  }
}

namespace vm68k
{
  /* Access methods for long word data.  */
  struct long_word
  {
    typedef uint32_type uint_type;
    typedef sint32_type sint_type;

    static uint32_type size() {return 4;}
    static uint32_type aligned_size() {return size();}
    static uint32_type max() {return 0xffffffff;}

    static uint32_type load(const memory &, uint32_type address,
			    function_code);
    static void store(memory &, uint32_type address,
		    uint32_type value, function_code);

    static uint32_type load_aligned_u(const memory &, uint32_type address,
					 function_code);
    static sint32_type load_aligned_s(const memory &, uint32_type address,
					 function_code);

    static const char *suffix() {return "l";}
  };

  inline uint32_type
  long_word::load(const memory &m, uint32_type address, function_code fc)
  {
    return m.load_32(address, fc);
  }

  inline void
  long_word::store(memory &m, uint32_type address,
		 uint32_type value, function_code fc)
  {
    m.store_32(address, value, fc);
  }

  inline uint32_type
  long_word::load_aligned_u(const memory &m, uint32_type address,
			       function_code fc)
  {
    return m.load_32(address, fc);
  }

  inline sint32_type
  long_word::load_aligned_s(const memory &m, uint32_type address,
			       function_code fc)
  {
    return normal_s(long_word(), load_aligned_u(m, address, fc));
  }
}

#endif /* not __VM68K_SIZE */
